#!/usr/bin/env python3

from matplotlib import cm, colors, pyplot
import descartes
import json
import matplotlib
import os
import pandas
import pymongo

# data sources
SOURCES = "sources/"
SHELTERS_JSON = "%s/shelters.json" % SOURCES
ROUTES_JSON = "%s/shelter_routes.json" % SOURCES

ACS5_CSV = "%s/acs5_2015_ma_subset.csv" % SOURCES
ACS5_GEOID_PREFIX = "15000US"
ACS5_POP_TOTAL_COL = "B01003e1"

BG_DB = "tiger_2016"
BG_COLLECTION = "blockgroups"

EVAC_DB = "massgis_mapserver"
EVAC_COLLECTION = "CityServices.Evacuation"
EVAC_EXCLUDE = ["ZONE A", "ZONE B", "ZONE C"]

# formatted data
OUTDIR = "analysis/"
UPDATED_ROUTES_TEMPLATE = "%s/routes_%%s_sorted.json" % OUTDIR
STATS_JSON_TEMPLATE = "%s/shelter_stats_%%s_%%s.json" % OUTDIR

# ignore
IGNORE_GEOIDS = [
    "250259901010", # ocean
    "250235001011", # hull
    "250259813001", # top right of boston logan, next to chelsea point
    "250251805002", # winthrop
    "250251805004" # winthrop
]

# appearance
COLORMAP = "YlOrRd"
#COLORMAP = "Paired"
#COLORMAP = "viridis_r"
COLOR_INACCESSIBLE = "#53323b"
BOSTON_GEOJSON = "sources/boston.geojson"
SHELTER_COLOR = "blue"
SHELTER_COLOR_UNUSED = "green"
SHELTER_MIN_SIZE = 2
SHELTER_MAX_SIZE = 5

def update_routes():
    """ Add information to and organize the raw data generated by simulate.py
    """

    with open(SHELTERS_JSON, "r") as f:
        shelter_info = json.load(f)

    def find_shelter(object_id):
        for shelter in shelter_info["features"]:
            if (shelter["properties"]["OBJECTID"] == object_id):
                return shelter

    for mode in ["walk", "drive", "transit"]:
        output = UPDATED_ROUTES_TEMPLATE % mode
        print("Creating %s" % output)

        with open(ROUTES_JSON, "r") as f_in, open(output, "w") as f_out:
            docs = []

            for line in f_in.readlines():
                doc = json.loads(line)
                doc.pop("_id")
                for shelter in doc["shelters"]:
                    shelter["coordinates"] = find_shelter(shelter["objectid"])["geometry"]["coordinates"]
                doc["shelters"] = sorted(
                    doc["shelters"],
                    key = lambda shelter: (
                        shelter["routes"][mode]
                        and shelter["routes"][mode]["duration"]
                        # arbitrarily large number pushes items without calculated
                        # routes to the end of the list
                        or 1e10
                    )
                )
                docs.append(doc)

            json.dump(docs, f_out, indent = 4)

class Renderer(object):

    def __init__(self):
        print("Loading acs5 csv")
        self.acs5 = pandas.read_csv(ACS5_CSV)
        self.acs5.index = self.acs5.pop("GEOID")

        self.colormap = cm.get_cmap(COLORMAP)

        self.mongo = pymongo.MongoClient()

    def render(self, mode, n_closest):
        print("Rendering %s, %d closest shelters" % (mode, n_closest))
        blockgroup_collection = self.mongo[BG_DB][BG_COLLECTION]
        figure, axis = pyplot.subplots()

        # Structure:
        #     key: String representation of shelter object ID
        #     value: Population that that shelter serves
        shelter_pops = {}

        # Contains dictionaries with the following indices:
        # avg_travel: The average travel time, or False if no routes could be
        #     made to this block group
        # geoid: GEOID string
        # geojson: GeoJSON dict
        # population: population int
        blockgroups = []

        with open(UPDATED_ROUTES_TEMPLATE % mode, "r") as f:
            docs = json.load(f)

        for doc in docs:
            if (not doc["blockgroup"]["geoid"] in IGNORE_GEOIDS):
                bg_geoid = doc["blockgroup"]["geoid"]

                bg_acs5_geoid = ACS5_GEOID_PREFIX + bg_geoid
                bg_pop = self.acs5[ACS5_POP_TOTAL_COL][bg_acs5_geoid]

                # list of the durations of the n closest paths, if any. ignores
                # all entries where the route is False; if the length is zero,
                # no routes could be made from this block group
                """
                travel_times = [
                    mode["duration"]
                    for mode in list(filter(
                        lambda x: x is not False,
                        [
                            shelter["routes"][mode] for shelter in doc["shelters"]
                        ]
                    ))[:n_closest]
                ]
                """

                travel_times = []

                for shelter in doc["shelters"]:

                    if (shelter["routes"][mode] is not False):
                        travel_times.append(
                            shelter["routes"][mode]["duration"]
                        )

                        object_id = str(shelter["objectid"])
                        if (object_id in shelter_pops):
                            shelter_pops[object_id] += bg_pop
                        else:
                            shelter_pops[object_id] = bg_pop

                    if (len(travel_times) == n_closest):
                        break

                if (len(travel_times) > 0):
                    bg_avg_travel = sum(travel_times) / len(travel_times)
                else:
                    bg_avg_travel = False

                print(bg_geoid, bg_pop, bg_avg_travel)

                blockgroups.append({
                    "avg_travel": bg_avg_travel / 60,
                    "geoid": bg_geoid,
                    "geojson": blockgroup_collection.find_one({
                        "properties.GEOID": bg_geoid
                    })["geometry"]["geometries"][1],
                    "population": bg_pop
                })

        print("Populations served by shelters: %s" % shelter_pops)

        axis.set_xlim([-71.2, -70.9])
        axis.set_ylim([42.21, 42.42])

        ## blockgroup plotting
        bg_travel = [blockgroup["avg_travel"] for blockgroup in blockgroups]
        min_bg_travel = min(bg_travel)
        max_bg_travel = max(bg_travel)
        bg_travel_range = max_bg_travel - min_bg_travel

        colormap_normalize = colors.Normalize(min_bg_travel, max_bg_travel)

        for blockgroup in blockgroups:
            if blockgroup["avg_travel"]:
                facecolor = self.colormap(
                    colormap_normalize(blockgroup["avg_travel"])
                )
            else:
                # rgb conversion is done for the value transformation
                facecolor = colors.to_rgb(COLOR_INACCESSIBLE)

            #edgecolor_hsv = colors.rgb_to_hsv(facecolor[:3])
            #edgecolor_hsv[2] *= 0.5

            axis.add_patch(descartes.PolygonPatch(
                blockgroup["geojson"],
                facecolor = facecolor,
                #edgecolor = colors.hsv_to_rgb(edgecolor_hsv)
                edgecolor = facecolor
            ))

        # plot Boston city boundaries
        with open(BOSTON_GEOJSON, "r") as f:
            axis.add_patch(descartes.PolygonPatch(
                json.load(f),
                facecolor = "none",
                edgecolor = "#bbbbbb",
                linewidth = 0.5
            ))

        ## shelter plotting
        shelter_pops_values = [
            shelter_pops[objectid] / 3
            for objectid in shelter_pops
        ]
        min_pop = min(shelter_pops_values)
        max_pop = max(shelter_pops_values)
        pop_range = max_pop - min_pop

        for shelter in doc["shelters"]:
            object_id = str(shelter["objectid"])

            if (object_id in shelter_pops):
                pop = shelter_pops[object_id]
                pop_normalized = (pop - min_pop) / pop_range
                axis.plot(
                    shelter["coordinates"][0],
                    shelter["coordinates"][1],
                    marker = "o",
                    markersize = SHELTER_MIN_SIZE + (
                        pop_normalized * (SHELTER_MAX_SIZE - SHELTER_MIN_SIZE)
                    ),
                    color = SHELTER_COLOR
                )

            # not among the n closest of any block group
            else:
                print(shelter)
                axis.plot(
                    shelter["coordinates"][0],
                    shelter["coordinates"][1],
                    marker = "o",
                    markersize = SHELTER_MIN_SIZE,
                    color = SHELTER_COLOR_UNUSED
                )

        ## final tweaks
        pyplot.title(
            "Relationships between block groups and the %d closest "
            "shelters; mode of transit = %s" % (n_closest, mode)
        )

        mappable = pyplot.cm.ScalarMappable(colormap_normalize, COLORMAP)
        mappable.set_array([min_bg_travel, max_bg_travel])
        colorbar = figure.colorbar(mappable)
        colorbar.set_label("Average transit time, in minutes")

        pyplot.show()
        pyplot.close()

if (__name__ == "__main__"):
    if (not os.path.isdir(OUTDIR)):
        os.mkdir(OUTDIR)

    #update_routes()
    r = Renderer()
    r.render("walk", 3)
